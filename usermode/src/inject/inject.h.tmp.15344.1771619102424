#pragma once
#include <Windows.h>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
#include <print>
#include <cstdint>

#include "../hypercall/hypercall.h"
#include "../system/system.h"
#include "../hook/hook.h"
#include "../hook/kernel_detour_holder.h"
#include <hypercall/hypercall_def.h>

namespace inject
{

// forward declare — full definition in the syscall exit hook section

//=============================================================================
// PE helpers
//=============================================================================

inline bool load_dll_file(const std::string& path, std::vector<uint8_t>& out_data)
{
	if (!std::filesystem::exists(path))
	{
		std::println("[-] DLL file not found: {}", path);
		return false;
	}

	std::ifstream file(path, std::ios::binary | std::ios::ate);
	if (!file.is_open()) return false;

	std::streamsize size = file.tellg();
	file.seekg(0, std::ios::beg);
	out_data.resize(size);
	return file.read(reinterpret_cast<char*>(out_data.data()), size).good();
}

inline PVOID rva_to_va(uintptr_t rva, PIMAGE_NT_HEADERS64 nt_headers, PVOID local_image)
{
	auto section = IMAGE_FIRST_SECTION(nt_headers);
	for (WORD i = 0; i < nt_headers->FileHeader.NumberOfSections; i++, section++)
	{
		if (rva >= section->VirtualAddress &&
		    rva < section->VirtualAddress + section->Misc.VirtualSize)
		{
			return (PUCHAR)local_image + section->PointerToRawData + (rva - section->VirtualAddress);
		}
	}
	return nullptr;
}

inline bool relocate_image(PVOID remote_base, PVOID local_image, PIMAGE_NT_HEADERS64 nt_headers)
{
	uintptr_t delta = (uintptr_t)remote_base - nt_headers->OptionalHeader.ImageBase;
	if (delta == 0) return true;

	if (!(nt_headers->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE))
		return false;

	auto reloc_dir = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	if (!reloc_dir->VirtualAddress || !reloc_dir->Size) return true;

	auto reloc_entry = (PIMAGE_BASE_RELOCATION)rva_to_va(reloc_dir->VirtualAddress, nt_headers, local_image);
	if (!reloc_entry) return true;

	uintptr_t reloc_end = (uintptr_t)reloc_entry + reloc_dir->Size;

	while ((uintptr_t)reloc_entry < reloc_end && reloc_entry->SizeOfBlock)
	{
		DWORD count = (reloc_entry->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
		PWORD reloc_data = (PWORD)((uintptr_t)reloc_entry + sizeof(IMAGE_BASE_RELOCATION));

		for (DWORD i = 0; i < count; i++)
		{
			WORD type = reloc_data[i] >> 12;
			WORD offset = reloc_data[i] & 0xFFF;

			if (type == IMAGE_REL_BASED_ABSOLUTE) continue;

			PVOID patch_addr = rva_to_va(reloc_entry->VirtualAddress + offset, nt_headers, local_image);
			if (!patch_addr) patch_addr = (PUCHAR)local_image + reloc_entry->VirtualAddress + offset;

			if (type == IMAGE_REL_BASED_HIGHLOW)
			{
				*(DWORD*)patch_addr += (DWORD)delta;
			}
			else if (type == IMAGE_REL_BASED_DIR64)
			{
				*(ULONG64*)patch_addr += delta;
			}
		}

		reloc_entry = (PIMAGE_BASE_RELOCATION)((uintptr_t)reloc_entry + reloc_entry->SizeOfBlock);
	}
	return true;
}

inline uintptr_t get_export_offset(const char* module_name, const char* func_name)
{
	HMODULE h_module = LoadLibraryExA(module_name, NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!h_module) return 0;
	auto proc = (uintptr_t)GetProcAddress(h_module, func_name);
	FreeLibrary(h_module);
	if (proc == 0) return 0;
	return proc - (uintptr_t)h_module;
}

inline bool resolve_imports(PVOID local_image, PIMAGE_NT_HEADERS64 nt_headers)
{
	auto import_dir = &nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	if (!import_dir->VirtualAddress || !import_dir->Size) return true;

	auto import_desc = (PIMAGE_IMPORT_DESCRIPTOR)rva_to_va(import_dir->VirtualAddress, nt_headers, local_image);
	if (!import_desc) return true;

	while (import_desc->Name)
	{
		auto module_name = (LPCSTR)rva_to_va(import_desc->Name, nt_headers, local_image);
		if (!module_name) break;

		uintptr_t module_base = (uintptr_t)LoadLibraryA(module_name);
		if (!module_base)
		{
			std::println("[-] Failed to load import module: {}", module_name);
			return false;
		}

		std::uint32_t module_import_count = 0;
		auto thunk = (PIMAGE_THUNK_DATA64)rva_to_va(import_desc->FirstThunk, nt_headers, local_image);
		while (thunk && thunk->u1.AddressOfData)
		{
			if (thunk->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
			{
				uintptr_t offset = get_export_offset(module_name, (LPCSTR)(thunk->u1.Ordinal & 0xFFFF));
				if (offset == 0)
				{
					std::println("[-] IMPORT FAIL: {}!Ordinal#{}", module_name, thunk->u1.Ordinal & 0xFFFF);
					return false;
				}
				thunk->u1.Function = module_base + offset;
			}
			else
			{
				auto import_by_name = (PIMAGE_IMPORT_BY_NAME)rva_to_va((uintptr_t)thunk->u1.AddressOfData, nt_headers, local_image);
				if (import_by_name)
				{
					uintptr_t offset = get_export_offset(module_name, import_by_name->Name);
					if (offset == 0)
					{
						std::println("[-] IMPORT FAIL: {}!{}", module_name, (const char*)import_by_name->Name);
						return false;
					}
					thunk->u1.Function = module_base + offset;
				}
			}
			module_import_count++;
			thunk++;
		}
		std::println("[+]   {} — {} imports @ base 0x{:X}", module_name, module_import_count, module_base);
		import_desc++;
	}
	return true;
}

inline bool write_sections(PVOID local_image, PIMAGE_NT_HEADERS64 nt_headers,
                           std::uint64_t hidden_base_va, std::uint64_t clone_cr3)
{
	auto section = IMAGE_FIRST_SECTION(nt_headers);
	for (WORD i = 0; i < nt_headers->FileHeader.NumberOfSections; i++, section++)
	{
		if (section->SizeOfRawData == 0) continue;

		PVOID src = (PVOID)((uintptr_t)local_image + section->PointerToRawData);
		std::uint64_t dst_va = hidden_base_va + section->VirtualAddress;

		std::uint64_t bytes_written = hypercall::write_guest_virtual_memory(
			src, dst_va, clone_cr3, section->SizeOfRawData);

		if (bytes_written != section->SizeOfRawData)
		{
			std::println("[-] Failed to write section {:.8s} ({} / {} bytes)",
				(char*)section->Name, bytes_written, section->SizeOfRawData);
			return false;
		}
	}
	return true;
}

//=============================================================================
// Syscall Exit EPT Hook — trigger DllMain at exact syscall return point
// Hooks KiSystemServiceExit so the trap frame is modified at the moment
// the kernel is done, right before IRETQ/SYSRET. One-shot via CPUID hypercall.
//=============================================================================

// Hijack data struct in hidden memory — only used by DllMain shellcode (usermode)
// original_rip and armed are now handled entirely by the hypervisor (no hidden memory access from ring 0)
typedef struct _HIJACK_DATA {
	INT Status;              // 0=pending, 1=running, 2=done
	INT SubStatus;           // diagnostic: 0x10=pre-RtlAddFnTable, 0x11=pre-entry, 0x12=post-entry
	uintptr_t FnDllMain;
	HINSTANCE DllBase;
	uintptr_t DllMainResult; // return value from _DllMainCRTStartup (0=FALSE, 1=TRUE)
} HIJACK_DATA;

inline std::uint64_t ksse_hook_va = 0; // stored for removal
inline std::uint16_t ksse_shellcode_detour_offset = 0; // detour holder allocation for our shellcode

// Build the EPT hook shellcode for KiSystemServiceExit (runs in ring 0)
// Stored in the detour holder page (not in extra_assembled_bytes, to avoid
// displacing 100+ bytes of original code — which breaks RIP-relative fixups).
//
// CRITICAL: NO hidden memory (PML4[70]) access from ring 0!
// The CR3 may be the original (not clone) when this fires.
// PML4[70] only exists in the clone → accessing it under original CR3 = #PF BSOD.
//
// All data exchange with hypervisor via CPUID hypercall:
//   - original_rip passed to handler in RDX (handler saves it)
//   - shellcode_va returned in RAX (handler returns it)
//
// Flow:
//   1. EPROCESS check (kernel memory — always accessible) → mismatch → skip
//   2. Read TrapFrame.Rip (kernel memory — always accessible)
//   3. CPUID atomic claim: pass original_rip in RDX → get shellcode_va in RAX
//   4. Write shellcode_va to TrapFrame.Rip
inline std::vector<uint8_t> build_syscall_exit_hook(
	std::uint64_t target_eprocess,
	std::uint32_t kthread_process_offset,
	std::uint32_t kthread_trapframe_offset)
{
	std::vector<uint8_t> sc;
	sc.reserve(100);

	auto push_u8 = [&](uint8_t b) { sc.push_back(b); };
	auto push_u32 = [&](uint32_t v) {
		for (int i = 0; i < 4; i++) sc.push_back(static_cast<uint8_t>(v >> (i * 8)));
	};
	auto push_u64 = [&](uint64_t v) {
		for (int i = 0; i < 8; i++) sc.push_back(static_cast<uint8_t>(v >> (i * 8)));
	};

	// Build the check_and_clear hypercall info (reserved_data=7 under read_guest_cr3)
	hypercall_info_t hijack_call = {};
	hijack_call.primary_key = hypercall_primary_key;
	hijack_call.secondary_key = hypercall_secondary_key;
	hijack_call.call_type = hypercall_type_t::read_guest_cr3;
	hijack_call.call_reserved_data = 7;
	std::uint32_t hijack_call_value = static_cast<std::uint32_t>(hijack_call.value);

	// push rax, rcx, rdx, rbx
	push_u8(0x50); // push rax
	push_u8(0x51); // push rcx
	push_u8(0x52); // push rdx
	push_u8(0x53); // push rbx

	// === Stage 1: EPROCESS check (kernel memory, always accessible) ===

	// mov rax, gs:[0x188]  — KPCR.CurrentThread
	push_u8(0x65); push_u8(0x48); push_u8(0x8B); push_u8(0x04); push_u8(0x25);
	push_u8(0x88); push_u8(0x01); push_u8(0x00); push_u8(0x00);

	// mov rcx, [rax + kthread_process_offset]  — KTHREAD.Process → EPROCESS
	push_u8(0x48); push_u8(0x8B); push_u8(0x88);
	push_u32(kthread_process_offset);

	// movabs rdx, <target_eprocess>
	push_u8(0x48); push_u8(0xBA);
	push_u64(target_eprocess);

	// cmp rcx, rdx
	push_u8(0x48); push_u8(0x3B); push_u8(0xCA);

	// jne .skip
	push_u8(0x75);
	const std::size_t jne1_pos = sc.size();
	push_u8(0x00); // placeholder

	// === Stage 2: Read TrapFrame.Rip (kernel memory, always accessible) ===

	// mov rcx, [rax + kthread_trapframe_offset]  — TrapFrame ptr
	push_u8(0x48); push_u8(0x8B); push_u8(0x88);
	push_u32(kthread_trapframe_offset);

	// mov rdx, [rcx + 0x168]  — original TrapFrame.Rip → RDX (passed to CPUID handler)
	push_u8(0x48); push_u8(0x8B); push_u8(0x91);
	push_u32(0x168);

	// === Stage 3: CPUID atomic claim (one VMEXIT, happens once) ===
	// RDX = original_rip (handler saves it)
	// Handler returns shellcode_va in RAX (or 0 if not armed / already claimed)

	// mov ecx, <hijack_call_value>
	push_u8(0xB9);
	push_u32(hijack_call_value);

	// cpuid  — VMEXIT: handler reads RDX, atomically disarms, returns shellcode_va
	push_u8(0x0F); push_u8(0xA2);

	// test rax, rax  (0 = not armed or race lost)
	push_u8(0x48); push_u8(0x85); push_u8(0xC0);

	// jz .skip
	push_u8(0x74);
	const std::size_t jz_cpuid_pos = sc.size();
	push_u8(0x00); // placeholder

	// === Stage 4: Claimed! RAX = shellcode_va ===

	// Re-read CurrentThread → TrapFrame (CPUID handler didn't clobber RCX/RDX
	// but ECX was set to hijack_call_value, so re-read to be safe)
	// mov rcx, gs:[0x188]
	push_u8(0x65); push_u8(0x48); push_u8(0x8B); push_u8(0x0C); push_u8(0x25);
	push_u8(0x88); push_u8(0x01); push_u8(0x00); push_u8(0x00);

	// mov rcx, [rcx + kthread_trapframe_offset]  — TrapFrame ptr
	push_u8(0x48); push_u8(0x8B); push_u8(0x89);
	push_u32(kthread_trapframe_offset);

	// mov [rcx + 0x168], rax  — overwrite TrapFrame.Rip = shellcode_va
	push_u8(0x48); push_u8(0x89); push_u8(0x81);
	push_u32(0x168);

	// .skip:
	const std::size_t skip_pos = sc.size();

	// pop rbx, rdx, rcx, rax
	push_u8(0x5B); // pop rbx
	push_u8(0x5A); // pop rdx
	push_u8(0x59); // pop rcx
	push_u8(0x58); // pop rax

	// Patch jump offsets
	sc[jne1_pos] = static_cast<uint8_t>(skip_pos - (jne1_pos + 1));
	sc[jz_cpuid_pos] = static_cast<uint8_t>(skip_pos - (jz_cpuid_pos + 1));

	return sc;
}

// Build the usermode DllMain shellcode (runs in user mode, hidden memory)
// Hypervisor writes original_rip directly into the stub's jmp placeholder
// during the CPUID(7) atomic claim — no usermode CPUID needed
inline std::vector<uint8_t> build_dllmain_shellcode(
	std::uint64_t dll_base, std::uint64_t entry_point_va,
	std::uint64_t data_va, std::uint16_t& out_rip_placeholder_offset,
	std::uint64_t rtl_add_fn_table_addr = 0,
	std::uint64_t pdata_va = 0,
	std::uint32_t pdata_entry_count = 0,
	bool skip_dllmain = false)
{
	std::vector<uint8_t> sc;
	sc.reserve(200);

	auto push_u8 = [&](uint8_t b) { sc.push_back(b); };
	auto push_u32 = [&](uint32_t v) {
		for (int i = 0; i < 4; i++) sc.push_back(static_cast<uint8_t>(v >> (i * 8)));
	};
	auto push_u64 = [&](uint64_t v) {
		for (int i = 0; i < 8; i++) sc.push_back(static_cast<uint8_t>(v >> (i * 8)));
	};

	// === Context save ===
	push_u8(0x9C);                   // pushfq
	push_u8(0x50);                   // push rax
	push_u8(0x51);                   // push rcx
	push_u8(0x52);                   // push rdx
	push_u8(0x53);                   // push rbx
	push_u8(0x6A); push_u8(0xFF);   // push -1 (rsp placeholder)
	push_u8(0x55);                   // push rbp
	push_u8(0x56);                   // push rsi
	push_u8(0x57);                   // push rdi
	push_u8(0x41); push_u8(0x50);   // push r8
	push_u8(0x41); push_u8(0x51);   // push r9
	push_u8(0x41); push_u8(0x52);   // push r10
	push_u8(0x41); push_u8(0x53);   // push r11
	push_u8(0x41); push_u8(0x54);   // push r12
	push_u8(0x41); push_u8(0x55);   // push r13
	push_u8(0x41); push_u8(0x56);   // push r14
	push_u8(0x41); push_u8(0x57);   // push r15

	// === Write Status = 1 (shellcode started, before DllMain) ===
	push_u8(0x48); push_u8(0xB9); push_u64(data_va);      // movabs rcx, data_va
	push_u8(0xC7); push_u8(0x01); push_u32(1);              // mov dword [rcx], 1

	if (!skip_dllmain)
	{
		// === Stack alignment ===
		push_u8(0x48); push_u8(0x89); push_u8(0xE3);           // mov rbx, rsp
		push_u8(0x48); push_u8(0x83); push_u8(0xE4); push_u8(0xF0); // and rsp, -16
		push_u8(0x48); push_u8(0x83); push_u8(0xEC); push_u8(0x30); // sub rsp, 0x30

		// SubStatus = 0x11 (about to call entry point)
		push_u8(0x48); push_u8(0xB9); push_u64(data_va);                  // movabs rcx, data_va
		push_u8(0xC7); push_u8(0x41); push_u8(0x04); push_u32(0x11);      // mov dword [rcx+4], 0x11

		// === Call _DllMainCRTStartup(hModule, DLL_PROCESS_ATTACH, NULL) ===
		push_u8(0x48); push_u8(0xB9); push_u64(dll_base);      // movabs rcx, dll_base (hModule)
		push_u8(0xBA); push_u32(1);                              // mov edx, 1 (DLL_PROCESS_ATTACH)
		push_u8(0x45); push_u8(0x33); push_u8(0xC0);           // xor r8d, r8d (lpReserved=NULL)
		push_u8(0x48); push_u8(0xB8); push_u64(entry_point_va); // movabs rax, entry_point
		push_u8(0xFF); push_u8(0xD0);                           // call rax

		// === Capture return value + SubStatus = 0x12 (entry returned) ===
		push_u8(0x48); push_u8(0xB9); push_u64(data_va);                  // movabs rcx, data_va
		push_u8(0x48); push_u8(0x89); push_u8(0x41); push_u8(0x18);      // mov [rcx+0x18], rax (DllMainResult @ offset 24)
		push_u8(0xC7); push_u8(0x41); push_u8(0x04); push_u32(0x12);      // mov dword [rcx+4], 0x12 (SubStatus: post-entry)
	}

	// === Write Status = 2 (DllMain completed / skipped) ===
	push_u8(0x48); push_u8(0xB9); push_u64(data_va);       // movabs rcx, data_va
	push_u8(0xC7); push_u8(0x01); push_u32(2);              // mov dword [rcx], 2

	// === Context restore ===
	if (!skip_dllmain)
	{
		push_u8(0x48); push_u8(0x89); push_u8(0xDC);       // mov rsp, rbx
	}

	push_u8(0x41); push_u8(0x5F);   // pop r15
	push_u8(0x41); push_u8(0x5E);   // pop r14
	push_u8(0x41); push_u8(0x5D);   // pop r13
	push_u8(0x41); push_u8(0x5C);   // pop r12
	push_u8(0x41); push_u8(0x5B);   // pop r11
	push_u8(0x41); push_u8(0x5A);   // pop r10
	push_u8(0x41); push_u8(0x59);   // pop r9
	push_u8(0x41); push_u8(0x58);   // pop r8
	push_u8(0x5F);                   // pop rdi
	push_u8(0x5E);                   // pop rsi
	push_u8(0x5D);                   // pop rbp
	push_u8(0x48); push_u8(0x83); push_u8(0xC4); push_u8(0x08); // add rsp, 8 (skip rsp placeholder)
	push_u8(0x5B);                   // pop rbx
	push_u8(0x5A);                   // pop rdx
	push_u8(0x59);                   // pop rcx
	push_u8(0x58);                   // pop rax
	push_u8(0x9D);                   // popfq

	// === Jump back to original RIP (written by hypervisor into stub during CPUID(7) claim) ===
	push_u8(0xFF); push_u8(0x25); push_u32(0x00000000);     // jmp [rip+0] — reads next 8 bytes as target
	out_rip_placeholder_offset = static_cast<std::uint16_t>(sc.size());
	push_u64(0);                                              // 8-byte placeholder (hypervisor fills this)

	return sc;
}

// Helper: build a 14-byte absolute jump (push low32 / mov [rsp+4], high32 / ret)
inline std::vector<std::uint8_t> build_abs_jmp(std::uint64_t target)
{
	std::vector<std::uint8_t> jmp;
	jmp.reserve(14);
	jmp.push_back(0x68); // push imm32 (low part)
	for (int i = 0; i < 4; i++) jmp.push_back(static_cast<uint8_t>(target >> (i * 8)));
	jmp.push_back(0xC7); jmp.push_back(0x44); jmp.push_back(0x24); jmp.push_back(0x04); // mov [rsp+4], imm32
	for (int i = 0; i < 4; i++) jmp.push_back(static_cast<uint8_t>(target >> (32 + i * 8)));
	jmp.push_back(0xC3); // ret
	return jmp;
}

// Install EPT hook on KiSystemServiceExit
// Strategy: store full shellcode in the detour holder page, use only a 14-byte
// trampoline as extra_assembled_bytes so only ~28 bytes of original code are
// displaced (instead of ~110, which would break RIP-relative instruction fixups).
//
// Flow: KiSystemServiceExit
//   → [14-byte jmp to shellcode in detour holder]  (extra_assembled_bytes)
//   → [our shellcode runs: EPROCESS check, TrapFrame.Rip overwrite]
//   → [14-byte jmp back to hook_va + 14]           (appended to shellcode)
//   → [14-byte jmp to detour holder original bytes] (add_kernel_hook's jmp_to_detour)
//   → [original displaced ~28 bytes + jmp back]     (normal detour)
inline bool install_syscall_exit_hook(std::uint64_t target_eprocess)
{
	if (sys::offsets::ki_system_service_exit_rva == 0)
	{
		std::println("[-] KiSystemServiceExit RVA not resolved");
		return false;
	}

	if (!sys::kernel::modules_list.contains("ntoskrnl.exe"))
	{
		std::println("[-] ntoskrnl.exe not in modules list");
		return false;
	}

	std::uint64_t ntoskrnl_base = sys::kernel::modules_list["ntoskrnl.exe"].base_address;
	std::uint64_t ksse_va = ntoskrnl_base + sys::offsets::ki_system_service_exit_rva;

	std::println("[+] KiSystemServiceExit VA: 0x{:X}", ksse_va);

	// 1. Build full ring-0 shellcode (NO hidden memory access)
	auto full_shellcode = build_syscall_exit_hook(
		target_eprocess,
		static_cast<std::uint32_t>(sys::offsets::kthread_process),
		static_cast<std::uint32_t>(sys::offsets::kthread_trap_frame));

	// Append 14-byte jmp back to ksse_va + 14 (past the trampoline, hits jmp_to_detour)
	auto return_jmp = build_abs_jmp(ksse_va + 14);
	full_shellcode.insert(full_shellcode.end(), return_jmp.begin(), return_jmp.end());

	std::println("[+] Syscall exit hook shellcode: {} bytes (with return jmp)", full_shellcode.size());

	// 2. Allocate space in detour holder for our shellcode
	void* sc_buffer = kernel_detour_holder::allocate_memory(
		static_cast<std::uint16_t>(full_shellcode.size()));

	if (sc_buffer == nullptr)
	{
		std::println("[-] Failed to allocate detour holder space for shellcode");
		return false;
	}

	ksse_shellcode_detour_offset = kernel_detour_holder::get_allocation_offset(sc_buffer);
	memcpy(sc_buffer, full_shellcode.data(), full_shellcode.size());

	std::uint64_t sc_kernel_va = hook::kernel_detour_holder_base + ksse_shellcode_detour_offset;

	std::println("[+] Shellcode in detour holder at offset 0x{:X} (kernel VA: 0x{:X})",
		ksse_shellcode_detour_offset, sc_kernel_va);

	// 3. Build trampoline: 14-byte jmp to our shellcode in detour holder
	auto trampoline = build_abs_jmp(sc_kernel_va);

	std::println("[+] Trampoline: {} bytes (only ~28 bytes of original code displaced)", trampoline.size());

	// 4. Install EPT hook with minimal displacement
	std::vector<std::uint8_t> post_original_bytes; // empty

	std::uint8_t status = hook::add_kernel_hook(ksse_va, trampoline, post_original_bytes);

	if (status == 1)
	{
		ksse_hook_va = ksse_va;
		std::println("[+] KiSystemServiceExit EPT hook installed at 0x{:X}", ksse_va);
		return true;
	}

	// Cleanup on failure
	kernel_detour_holder::free_memory(sc_buffer);
	ksse_shellcode_detour_offset = 0;
	std::println("[-] Failed to install KiSystemServiceExit EPT hook");
	return false;
}

inline bool remove_syscall_exit_hook()
{
	if (ksse_hook_va == 0) return false;

	std::uint8_t status = hook::remove_kernel_hook(ksse_hook_va, 1);
	if (status == 1)
	{
		std::println("[+] KiSystemServiceExit EPT hook removed");
		ksse_hook_va = 0;

		// Free our shellcode allocation in detour holder
		if (ksse_shellcode_detour_offset != 0)
		{
			void* sc_alloc = kernel_detour_holder::get_allocation_from_offset(ksse_shellcode_detour_offset);
			kernel_detour_holder::free_memory(sc_alloc);
			ksse_shellcode_detour_offset = 0;
		}

		return true;
	}

	std::println("[-] Failed to remove KiSystemServiceExit EPT hook");
	return false;
}

// Main hijack function: installs EPT hook, arms hijack, waits for DllMain completion
inline bool hijack_thread(std::uint64_t clone_cr3, std::uint64_t target_cr3,
                          std::uint64_t target_eprocess,
                          std::uint64_t hidden_base_va, std::uint64_t dll_base,
                          DWORD entry_point_rva, std::uint64_t shellcode_page_index,
                          std::uint64_t rtl_add_fn_table_addr = 0,
                          std::uint64_t pdata_va = 0,
                          std::uint32_t pdata_entry_count = 0,
                          bool skip_dllmain = false)
{
	// 1. Shellcode + data layout on the last hidden page
	std::uint64_t shellcode_va = hidden_base_va + (shellcode_page_index * 0x1000);
	std::uint64_t entry_point_va = dll_base + entry_point_rva;

	// Data struct at offset 0x800 on the shellcode page
	std::uint64_t data_va = shellcode_va + 0x800;

	std::println("[+] Shellcode VA: 0x{:X}, Data VA: 0x{:X}", shellcode_va, data_va);
	std::println("[+] DLL entry point: 0x{:X}", entry_point_va);

	// 2. Build usermode DllMain shellcode (hypervisor writes original_rip to stub)
	std::uint16_t rip_placeholder_offset = 0;
	auto shellcode = build_dllmain_shellcode(dll_base, entry_point_va, data_va, rip_placeholder_offset,
		rtl_add_fn_table_addr, pdata_va, pdata_entry_count, skip_dllmain);
	std::println("[+] DllMain shellcode: {} bytes, rip_offset=0x{:X} (skip_dllmain={}, RtlAddFnTable=0x{:X}, pdata_entries={})",
		shellcode.size(), rip_placeholder_offset, skip_dllmain, rtl_add_fn_table_addr, pdata_entry_count);

	// 4. Prepare HIJACK_DATA
	HIJACK_DATA hijack_data = {};
	hijack_data.Status = 0;
	hijack_data.SubStatus = 0;
	hijack_data.FnDllMain = (uintptr_t)entry_point_va;
	hijack_data.DllBase = (HINSTANCE)dll_base;
	hijack_data.DllMainResult = 0;

	// 5. Write shellcode + data to hidden memory (via clone CR3)
	std::uint64_t written = hypercall::write_guest_virtual_memory(
		shellcode.data(), shellcode_va, clone_cr3, shellcode.size());

	if (written != shellcode.size())
	{
		std::println("[-] Failed to write shellcode ({} / {} bytes)", written, shellcode.size());
		return false;
	}

	written = hypercall::write_guest_virtual_memory(
		&hijack_data, data_va, clone_cr3, sizeof(hijack_data));

	if (written != sizeof(hijack_data))
	{
		std::println("[-] Failed to write HIJACK_DATA");
		return false;
	}

	// Verify shellcode was written
	uint8_t verify[4] = {};
	hypercall::read_guest_virtual_memory(verify, shellcode_va, clone_cr3, 4);
	std::println("[+] Shellcode verify: {:02X} {:02X} {:02X} {:02X} (expected 9C 50 51 52)",
		verify[0], verify[1], verify[2], verify[3]);

	// 6. Install EPT hook on KiSystemServiceExit (no hidden memory params needed)
	if (!install_syscall_exit_hook(target_eprocess))
	{
		std::println("[-] Failed to install syscall exit EPT hook");
		return false;
	}

	// 7. Arm the hijack (hypervisor writes original_rip to stub at rip_placeholder_offset)
	hypercall::arm_syscall_hijack(shellcode_va, rip_placeholder_offset);
	std::println("[+] Syscall hijack armed with shellcode VA 0x{:X}, rip_offset=0x{:X}", shellcode_va, rip_placeholder_offset);

	// 8. Print stats
	std::println("[+] CR3 stats: exits={} swaps={} mmaf_hits={} ept_violations={}",
		hypercall::read_cr3_exit_count(), hypercall::read_cr3_swap_count(),
		hypercall::read_mmaf_hit_count(), hypercall::read_slat_violation_count());

	std::println("[+] Waiting for DllMain (target process will trigger on next syscall return)...");

	// 9. Poll for completion
	HIJACK_DATA remote_status = {};
	bool saw_status_1 = false;
	for (int attempt = 0; attempt < 100; attempt++)
	{
		Sleep(100);
		hypercall::read_guest_virtual_memory(&remote_status, data_va, clone_cr3, sizeof(remote_status));

		if (remote_status.Status == 1 && !saw_status_1)
		{
			saw_status_1 = true;
			std::println("[+] CANARY HIT: Status=1 — shellcode is executing! (attempt {})", attempt);
		}

		if (remote_status.Status == 2)
		{
			std::println("[+] DllMain completed! (Status=2, SubStatus=0x{:X}, Result=0x{:X}, attempt {})",
				remote_status.SubStatus, remote_status.DllMainResult, attempt);
			if (remote_status.DllMainResult == 0)
				std::println("[!] WARNING: Entry point returned FALSE — CRT init may have failed");
			break;
		}

		if (attempt % 10 == 9)
		{
			std::println("[*] Still waiting... Status={}, mmaf_hits={}, swaps={}, exits={}, ept_violations={}",
				remote_status.Status, hypercall::read_mmaf_hit_count(),
				hypercall::read_cr3_swap_count(), hypercall::read_cr3_exit_count(),
				hypercall::read_slat_violation_count());
		}
	}

	// 10. Cleanup: remove syscall exit hook, disarm
	remove_syscall_exit_hook();
	hypercall::disarm_syscall_hijack();

	if (remote_status.Status != 2)
	{
		std::println("[!] DllMain did not complete (Status={})", remote_status.Status);
		if (saw_status_1)
			std::println("[!] Status=1 was seen — shellcode ran, DllMain CRASHED");
		else
			std::println("[!] Status stayed 0 — EPT hook may not have fired");

		std::println("[+] Final CR3 stats: exits={} swaps={} mmaf_hits={} ept_violations={}",
			hypercall::read_cr3_exit_count(), hypercall::read_cr3_swap_count(),
			hypercall::read_mmaf_hit_count(), hypercall::read_slat_violation_count());
	}

	return remote_status.Status == 2;
}

//=============================================================================
// MmAccessFault EPT Hook
// Intercepts page faults on hidden memory (PML4[70]) and swaps CR3 to clone
// so the faulting instruction retries under the clone where hidden pages exist.
//=============================================================================

inline std::uint64_t mmaf_hook_va = 0; // stored for removal
inline std::uint16_t mmaf_shellcode_detour_offset = 0; // detour holder allocation

// Build MmAccessFault check shellcode (runs in detour holder, NOT as extra_assembled_bytes)
// This is the trampoline approach: only 14 bytes on the shadow page, full shellcode in
// the detour holder. Reduces displacement from ~50 to ~28 bytes of original MmAccessFault
// prologue, avoiding RIP-relative fixup issues in deeper prologue instructions.
//
// Flow when called via trampoline:
//   Stack: [caller_return_addr | shadow_space...]  (trampoline push+ret preserves stack)
//   Hidden path: CPUID swap → return STATUS_SUCCESS to caller
//   Not-hidden path: jmp back to mmaf_va+14 → jmp_to_detour → displaced original bytes
inline std::vector<std::uint8_t> build_mmaf_shellcode(
	std::uint64_t mmaf_va,
	std::uint32_t hypercall_value,
	std::uint64_t clone_cr3,
	std::uint64_t hidden_pml4_index)
{
	std::vector<std::uint8_t> sc;
	sc.reserve(80);

	auto push_u8 = [&](uint8_t b) { sc.push_back(b); };
	auto push_u32 = [&](uint32_t v) {
		for (int i = 0; i < 4; i++) sc.push_back(static_cast<uint8_t>(v >> (i * 8)));
	};
	auto push_u64 = [&](uint64_t v) {
		for (int i = 0; i < 8; i++) sc.push_back(static_cast<uint8_t>(v >> (i * 8)));
	};

	// push rax
	push_u8(0x50);
	// push rbx (CPUID clobbers EBX)
	push_u8(0x53);
	// mov rax, rdx  — RDX = faulting virtual address (MmAccessFault param 2)
	push_u8(0x48); push_u8(0x8B); push_u8(0xC2);
	// shr rax, 39  — extract PML4 index
	push_u8(0x48); push_u8(0xC1); push_u8(0xE8); push_u8(0x27);
	// and eax, 0x1FF  — mask to 9 bits
	push_u8(0x25); push_u8(0xFF); push_u8(0x01); push_u8(0x00); push_u8(0x00);
	// cmp eax, <pml4_index>
	push_u8(0x83); push_u8(0xF8); push_u8(static_cast<uint8_t>(hidden_pml4_index));
	// jne .not_hidden
	push_u8(0x75);
	const std::size_t jne_pos = sc.size();
	push_u8(0x00); // placeholder

	// --- hidden path: CPUID swap + return STATUS_SUCCESS ---
	const std::size_t hidden_start = sc.size();

	// mov ecx, <hypercall_value>
	push_u8(0xB9); push_u32(hypercall_value);
	// movabs rdx, <clone_cr3>
	push_u8(0x48); push_u8(0xBA); push_u64(clone_cr3);
	// cpuid — VMEXIT: writes clone_cr3 to guest CR3
	push_u8(0x0F); push_u8(0xA2);
	// pop rbx
	push_u8(0x5B);
	// pop rax
	push_u8(0x58);
	// xor eax, eax  — STATUS_SUCCESS
	push_u8(0x33); push_u8(0xC0);
	// ret  — return to MmAccessFault's caller
	push_u8(0xC3);

	// patch jne offset
	sc[jne_pos] = static_cast<uint8_t>(sc.size() - hidden_start);

	// --- .not_hidden: restore regs, jmp back to mmaf_va+14 ---
	// pop rbx
	push_u8(0x5B);
	// pop rax
	push_u8(0x58);

	// 14-byte absolute jmp back to mmaf_va + 14 (past the trampoline, hits jmp_to_detour)
	auto return_jmp = build_abs_jmp(mmaf_va + 14);
	sc.insert(sc.end(), return_jmp.begin(), return_jmp.end());

	return sc;
}

inline bool install_mmaf_hook(std::uint64_t clone_cr3, std::uint64_t hidden_pml4_index = 70)
{
	// compute MmAccessFault VA from RVA + ntoskrnl base
	if (sys::offsets::mm_access_fault_rva == 0)
	{
		std::println("[-] MmAccessFault RVA not resolved (PDB failed?)");
		return false;
	}

	if (sys::kernel::modules_list.contains("ntoskrnl.exe") == false)
	{
		std::println("[-] ntoskrnl.exe not in modules list");
		return false;
	}

	std::uint64_t ntoskrnl_base = sys::kernel::modules_list["ntoskrnl.exe"].base_address;
	std::uint64_t mmaf_va = ntoskrnl_base + sys::offsets::mm_access_fault_rva;

	std::println("[+] MmAccessFault VA: 0x{:X}", mmaf_va);

	// build hypercall_info for write_guest_cr3
	hypercall_info_t call_info = {};
	call_info.primary_key = hypercall_primary_key;
	call_info.secondary_key = hypercall_secondary_key;
	call_info.call_type = hypercall_type_t::write_guest_cr3;
	call_info.call_reserved_data = 0;

	std::uint32_t hypercall_value = static_cast<std::uint32_t>(call_info.value);

	// 1. Build full MmAccessFault check shellcode (runs in detour holder)
	auto full_shellcode = build_mmaf_shellcode(mmaf_va, hypercall_value, clone_cr3, hidden_pml4_index);

	std::println("[+] MmAccessFault shellcode: {} bytes (with return jmp), clone_cr3=0x{:X}",
		full_shellcode.size(), clone_cr3);

	// 2. Allocate space in detour holder for our shellcode
	void* sc_buffer = kernel_detour_holder::allocate_memory(
		static_cast<std::uint16_t>(full_shellcode.size()));

	if (sc_buffer == nullptr)
	{
		std::println("[-] Failed to allocate detour holder space for MmAccessFault shellcode");
		return false;
	}

	mmaf_shellcode_detour_offset = kernel_detour_holder::get_allocation_offset(sc_buffer);
	memcpy(sc_buffer, full_shellcode.data(), full_shellcode.size());

	std::uint64_t sc_kernel_va = hook::kernel_detour_holder_base + mmaf_shellcode_detour_offset;

	std::println("[+] MmAccessFault shellcode in detour holder at offset 0x{:X} (kernel VA: 0x{:X})",
		mmaf_shellcode_detour_offset, sc_kernel_va);

	// 3. Build trampoline: 14-byte jmp to our shellcode in detour holder
	auto trampoline = build_abs_jmp(sc_kernel_va);

	std::println("[+] Trampoline: {} bytes (only ~28 bytes of MmAccessFault prologue displaced)", trampoline.size());

	// 4. Install EPT hook with minimal displacement
	std::vector<std::uint8_t> post_original_bytes; // empty

	std::uint8_t status = hook::add_kernel_hook(mmaf_va, trampoline, post_original_bytes);

	if (status == 1)
	{
		mmaf_hook_va = mmaf_va;
		std::println("[+] MmAccessFault EPT hook installed at 0x{:X}", mmaf_va);
		return true;
	}

	// Cleanup on failure
	kernel_detour_holder::free_memory(sc_buffer);
	mmaf_shellcode_detour_offset = 0;
	std::println("[-] Failed to install MmAccessFault EPT hook");
	return false;
}

inline bool remove_mmaf_hook()
{
	if (mmaf_hook_va == 0)
	{
		std::println("[-] No MmAccessFault hook to remove");
		return false;
	}

	std::uint8_t status = hook::remove_kernel_hook(mmaf_hook_va, 1);

	if (status == 1)
	{
		std::println("[+] MmAccessFault EPT hook removed");
		mmaf_hook_va = 0;

		// Free our shellcode allocation in detour holder
		if (mmaf_shellcode_detour_offset != 0)
		{
			void* sc_alloc = kernel_detour_holder::get_allocation_from_offset(mmaf_shellcode_detour_offset);
			kernel_detour_holder::free_memory(sc_alloc);
			mmaf_shellcode_detour_offset = 0;
		}

		return true;
	}

	std::println("[-] Failed to remove MmAccessFault EPT hook");
	return false;
}

//=============================================================================
// Main injection entry point
//=============================================================================

inline bool inject_dll(const std::string& dll_path, const std::string& process_name)
{
	// cleanup any stale CR3 intercept from previous run
	hypercall::disable_cr3_intercept();

	// 1. Find target process
	auto process = sys::process::find_process_by_name(process_name);
	if (!process.has_value())
	{
		std::println("[-] Process '{}' not found", process_name);
		return false;
	}

	std::println("[+] Found {} (PID: {}, CR3: 0x{:X}, EPROCESS: 0x{:X})",
		process->name, process->pid, process->cr3, process->eprocess);

	// 2. Clone CR3
	std::uint64_t cloned_cr3 = hypercall::clone_guest_cr3(process->cr3);
	if (cloned_cr3 == 0)
	{
		std::println("[-] Failed to clone CR3");
		return false;
	}

	std::println("[+] Cloned CR3: 0x{:X}", cloned_cr3);

	// 3. Enable CR3 intercept
	std::uint64_t icr3_result = hypercall::enable_cr3_intercept(process->cr3, cloned_cr3);
	if (icr3_result == 0)
	{
		std::println("[-] Failed to enable CR3 intercept");
		return false;
	}

	std::println("[+] CR3 intercept enabled");

	// 4. Load DLL from disk
	std::vector<uint8_t> dll_image;
	if (!load_dll_file(dll_path, dll_image))
	{
		std::println("[-] Failed to load DLL: {}", dll_path);
		return false;
	}

	auto dos_header = (PIMAGE_DOS_HEADER)dll_image.data();
	auto nt_headers = (PIMAGE_NT_HEADERS64)(dll_image.data() + dos_header->e_lfanew);

	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE || nt_headers->Signature != IMAGE_NT_SIGNATURE)
	{
		std::println("[-] Invalid PE signature");
		return false;
	}

	DWORD entry_point_rva = nt_headers->OptionalHeader.AddressOfEntryPoint;
	SIZE_T image_size = nt_headers->OptionalHeader.SizeOfImage;
	std::uint64_t pages_needed = (image_size + 0xFFF) / 0x1000;
	std::uint64_t shellcode_page = pages_needed; // one extra page for shellcode
	std::uint64_t total_pages = pages_needed + 1;

	std::println("[+] DLL: {} bytes, {} pages + 1 shellcode page", image_size, pages_needed);

	// 5. Setup hidden region (PML4[70])
	constexpr std::uint64_t hidden_pml4_index = 70;
	std::uint64_t hidden_base_va = hypercall::setup_hidden_region(hidden_pml4_index);
	if (hidden_base_va == 0)
	{
		std::println("[-] Failed to setup hidden region");
		return false;
	}

	std::println("[+] Hidden region at VA 0x{:X}", hidden_base_va);

	// 6. Map all needed pages
	for (std::uint64_t i = 0; i < total_pages; i++)
	{
		std::uint64_t result = hypercall::map_hidden_page(i);
		if (result == 0)
		{
			std::println("[-] Failed to map hidden page {}", i);
			return false;
		}
	}

	std::println("[+] Mapped {} hidden pages", total_pages);

	// 6b. Register UserDirectoryTableBase for CR3 write interception (KPTI fix)
	// KPTI: kernel exit writes UserDTB to CR3. Without intercepting this,
	// the CR3 swap to clone is undone. Now the hypervisor intercepts both PFNs.
	constexpr std::uint64_t kprocess_user_dtb_offset = 0x280; // KPROCESS.UserDirectoryTableBase
	std::uint64_t user_dtb = 0;
	hypercall::read_guest_virtual_memory(&user_dtb,
		process->eprocess + kprocess_user_dtb_offset,
		sys::current_cr3, 8);

	if (user_dtb != 0)
	{
		std::println("[+] UserDirectoryTableBase: 0x{:X}", user_dtb);
		std::uint64_t result = hypercall::set_user_cr3(user_dtb);
		if (result)
			std::println("[+] Registered UserDTB PFN for CR3 interception");
		else
			std::println("[!] WARNING: Failed to register UserDTB");
	}
	else
	{
		std::println("[!] WARNING: UserDirectoryTableBase is 0 (KPTI disabled or wrong offset)");
	}

	// 7. Relocate image
	if (!relocate_image((PVOID)hidden_base_va, dll_image.data(), nt_headers))
	{
		std::println("[-] Failed to relocate image");
		return false;
	}

	std::println("[+] Relocations applied (delta: 0x{:X})",
		hidden_base_va - nt_headers->OptionalHeader.ImageBase);

	// 8. Resolve imports
	if (!resolve_imports(dll_image.data(), nt_headers))
	{
		std::println("[-] Failed to resolve imports");
		return false;
	}

	std::println("[+] Imports resolved");

	// 9. Zero-fill entire image area, then write PE header + sections
	// CRITICAL: PE loader zeroes the full SizeOfImage before mapping sections.
	// Without this, BSS (zero-initialized globals) and section gaps contain
	// stale heap data. CRT globals like __scrt_current_native_startup_state
	// need to be 0 — garbage values cause _DllMainCRTStartup to return FALSE.
	{
		std::vector<uint8_t> zero_page(0x1000, 0);
		for (std::uint64_t i = 0; i < pages_needed; i++)
		{
			hypercall::write_guest_virtual_memory(
				zero_page.data(), hidden_base_va + i * 0x1000, cloned_cr3, 0x1000);
		}
		std::println("[+] Zero-filled {} image pages (BSS/section gaps clean)", pages_needed);
	}

	{
		DWORD headers_size = nt_headers->OptionalHeader.SizeOfHeaders;
		std::uint64_t hdr_written = hypercall::write_guest_virtual_memory(
			dll_image.data(), hidden_base_va, cloned_cr3, headers_size);
		std::println("[+] PE header written: {} / {} bytes", hdr_written, headers_size);
	}

	if (!write_sections(dll_image.data(), nt_headers, hidden_base_va, cloned_cr3))
	{
		std::println("[-] Failed to write sections");
		return false;
	}

	std::println("[+] Sections written to hidden memory");

	// 10. Verify hidden memory is accessible under clone CR3 but NOT under original
	std::uint16_t verify_mz = 0;
	hypercall::read_guest_virtual_memory(&verify_mz, hidden_base_va, cloned_cr3, 2);
	std::uint64_t verify_orig = 0;
	std::uint64_t orig_read = hypercall::read_guest_virtual_memory(&verify_orig, hidden_base_va, process->cr3, 8);
	std::println("[+] Hidden base via clone: 0x{:X} (should be 0x5A4D = MZ)", verify_mz);
	std::println("[+] Hidden base via original: {} bytes read (should be 0 = unmapped)", orig_read);

	// Also verify first section (.text)
	auto first_section = IMAGE_FIRST_SECTION(nt_headers);
	if (first_section->SizeOfRawData > 0)
	{
		std::uint64_t text_va = hidden_base_va + first_section->VirtualAddress;
		std::uint8_t text_verify[16] = {};
		hypercall::read_guest_virtual_memory(text_verify, text_va, cloned_cr3, 16);
		std::println("[+] .text section at 0x{:X}: {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X}",
			text_va, text_verify[0], text_verify[1], text_verify[2], text_verify[3],
			text_verify[4], text_verify[5], text_verify[6], text_verify[7]);
	}

	// 11. Install MmAccessFault EPT hook (catches #PF on hidden memory, swaps CR3)
	if (!install_mmaf_hook(cloned_cr3, hidden_pml4_index))
	{
		std::println("[!] WARNING: MmAccessFault hook failed, injection may not work");
	}
	else
	{
		// verify hook is in the list
		std::println("[+] MmAccessFault hook in kernel_hook_list: {}",
			hook::kernel_hook_list.contains(mmaf_hook_va) ? "YES" : "NO");

		// verify shadow page content directly (our process memory, no EPT involved)
		// NOTE: read_guest_virtual_memory returns zeros for hooked pages because EPT has read=0
		// in hyperv_cr3. This is EXPECTED. Instead, read the shadow page directly.
		if (hook::kernel_hook_list.contains(mmaf_hook_va))
		{
			auto& hook_info = hook::kernel_hook_list[mmaf_hook_va];
			std::uint8_t* shadow = static_cast<std::uint8_t*>(hook_info.get_mapped_shadow_page());
			std::uint64_t page_offset = mmaf_hook_va & 0xFFF;
			std::uint64_t orig_pfn = hook_info.original_page_pfn;
			std::println("[+] Shadow page offset: 0x{:X}, original_pfn: 0x{:X}",
				page_offset, orig_pfn);
			std::println("[+] Shadow page content (trampoline): {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X} {:02X}",
				shadow[page_offset+0], shadow[page_offset+1], shadow[page_offset+2], shadow[page_offset+3],
				shadow[page_offset+4], shadow[page_offset+5], shadow[page_offset+6], shadow[page_offset+7],
				shadow[page_offset+8], shadow[page_offset+9], shadow[page_offset+10], shadow[page_offset+11],
				shadow[page_offset+12], shadow[page_offset+13]);
			std::println("[+] (should be: 68 xx xx xx xx C7 44 24 04 xx xx xx xx C3 = abs jmp to detour holder)");
		}
	}

	// 12. Print stats before trigger
	std::println("[+] CR3 stats before trigger: exits={} swaps={} mmaf_hits={} ept_violations={}",
		hypercall::read_cr3_exit_count(), hypercall::read_cr3_swap_count(), hypercall::read_mmaf_hit_count(),
		hypercall::read_slat_violation_count());

	// 13. Call DllMain via syscall hijack (trap frame RIP overwrite)
	// skip_dllmain=true: shellcode writes Status=1→2 without calling DllMain (debug BSOD)
	constexpr bool skip_dllmain_debug = false;
	bool dllmain_result = hijack_thread(
		cloned_cr3, process->cr3, process->eprocess,
		hidden_base_va, hidden_base_va, entry_point_rva, shellcode_page,
		0, 0, 0, // RtlAddFunctionTable disabled (detectable by EAC via RtlpDynamicFunctionTable)
		skip_dllmain_debug);

	// Print mmaf hit count after trigger
	std::println("[+] mmaf_hit_count after trigger: {}, ept_violations: {}", hypercall::read_mmaf_hit_count(), hypercall::read_slat_violation_count());

	// === Read CRT diagnostic data from hidden memory ===
	// Scan .diag section for marker 0xD1A6D1A6
	{
		// Re-parse PE to find .diag section
		auto scan_dos = (PIMAGE_DOS_HEADER)dll_image.data();
		auto scan_nt = (PIMAGE_NT_HEADERS64)(dll_image.data() + scan_dos->e_lfanew);
		auto scan_sec = IMAGE_FIRST_SECTION(scan_nt);
		for (WORD si = 0; si < scan_nt->FileHeader.NumberOfSections; si++, scan_sec++)
		{
			if (memcmp(scan_sec->Name, ".diag", 5) == 0)
			{
				std::uint64_t diag_va = hidden_base_va + scan_sec->VirtualAddress;
				std::uint64_t diag_size = scan_sec->Misc.VirtualSize;
				if (diag_size > 0x1000) diag_size = 0x1000;

				std::vector<std::uint8_t> diag_buf(diag_size);
				hypercall::read_guest_virtual_memory(diag_buf.data(), diag_va, cloned_cr3, diag_size);

				// Check marker
				std::uint32_t marker = *(std::uint32_t*)diag_buf.data();
				if (marker == 0xD1A6D1A6)
				{
					int phase = *(int*)(diag_buf.data() + 4);
					int total = *(int*)(diag_buf.data() + 8);
					int failed_idx = *(int*)(diag_buf.data() + 12);
					int failed_ret = *(int*)(diag_buf.data() + 16);
					int last_err = *(int*)(diag_buf.data() + 20);
					std::uint64_t failed_fn = *(std::uint64_t*)(diag_buf.data() + 24);
					int* results = (int*)(diag_buf.data() + 32);

					std::println("[DIAG] Phase: {} (1=initterm_e, 2=initterm, 3=DllMain)", phase);
					std::println("[DIAG] Total initializers: {}", total);

					if (failed_idx >= 0)
					{
						std::println("[DIAG] *** FAILED at index {} ***", failed_idx);
						std::println("[DIAG] Failed fn addr: 0x{:X}", failed_fn);
						std::println("[DIAG] Failed fn RVA:  0x{:X}", failed_fn - hidden_base_va);
						std::println("[DIAG] Return value: {}", failed_ret);
						std::println("[DIAG] GetLastError: {}", last_err);
					}
					else if (phase >= 1)
					{
						std::println("[DIAG] All {} initializers passed!", total);
					}

					// Print per-initializer results
					int max_print = (total < 32) ? total : 32;
					for (int ri = 0; ri < max_print; ri++)
					{
						if (results[ri] == 0)
							std::println("[DIAG]   [{}] null/skipped", ri);
						else if (results[ri] == 1)
							std::println("[DIAG]   [{}] OK", ri);
						else
							std::println("[DIAG]   [{}] FAILED (ret={})", ri, -results[ri]);
					}
				}
				else
				{
					std::println("[DIAG] Marker not found (got 0x{:X}) — _initterm_e override may not be linked", marker);
				}
				break;
			}
		}
	}

	if (dllmain_result)
	{
		std::println("[+] Injection complete - DLL running in hidden memory at 0x{:X}", hidden_base_va);
	}
	else
	{
		std::println("[-] DllMain execution failed or timed out");
	}

	// DLL is persistent (runs threads, hooks PresentThread) — keep infrastructure active:
	//   - CR3 intercept: swaps to clone on MOV CR3 (context switch)
	//   - MmAccessFault hook: swaps to clone on PML4[70] page fault
	//   - UserDTB interception: handles KPTI user/kernel DTB swap
	// Only the KiSSE hook was removed inside hijack_thread() after DllMain returned.
	if (!dllmain_result)
	{
		// DllMain failed — tear down everything
		if (user_dtb != 0)
		{
			hypercall::clear_user_cr3();
			std::println("[*] UserDTB interception cleared");
		}
		std::println("[*] Removing MmAccessFault hook...");
		remove_mmaf_hook();
		std::println("[*] Disabling CR3 intercept...");
		hypercall::disable_cr3_intercept();
	}
	else
	{
		std::println("[+] DLL persistent — CR3 intercept + MmAccessFault hook remain active");
	}

	return dllmain_result;
}

//=============================================================================
// Uninject: tear down all hooks and restore clean state
//=============================================================================

inline void uninject()
{
	std::println("[*] Tearing down injection infrastructure...");

	// 1. Disarm any pending syscall hijack
	hypercall::disarm_syscall_hijack();

	// 2. Remove KiSystemServiceExit hook (if still active)
	if (ksse_hook_va != 0)
	{
		remove_syscall_exit_hook();
		std::println("[+] KiSystemServiceExit hook removed");
	}

	// 3. Remove MmAccessFault hook
	if (mmaf_hook_va != 0)
	{
		remove_mmaf_hook();
		std::println("[+] MmAccessFault hook removed");
	}
	else
	{
		std::println("[*] MmAccessFault hook not active");
	}

	// 4. Clear UserDTB interception
	hypercall::clear_user_cr3();
	std::println("[+] UserDTB interception cleared");

	// 5. Disable CR3 intercept (also resets enforce_active)
	hypercall::disable_cr3_intercept();
	std::println("[+] CR3 intercept disabled");

	// 6. Print final stats
	std::println("[+] Final stats: exits={} swaps={} mmaf_hits={} ept_violations={}",
		hypercall::read_cr3_exit_count(), hypercall::read_cr3_swap_count(),
		hypercall::read_mmaf_hit_count(), hypercall::read_slat_violation_count());

	std::println("[+] Clean state restored — safe to reinject or exit");
}

} // namespace inject
